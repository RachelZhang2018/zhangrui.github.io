---

layout: post

title: "Leetcode-动态规划"

---

# 一维动态规划

## 121最大收益

DP (dynamic programming)

DP的思路： 利用原问题与子问题的关系，将其变成 大问题的解 = 小问题的解的函数， 从而将问题变成size的扩展即可，当size到达最大后，原问题解决了

DP的keypoint

1. 转移方程（大问题与小问题的关系）

   ```
    1）定义状态：定义一个状态，例如f(i) = 到a[i]为止到最小值
    2）设计转移方程：根据如上状态方程定义，则有 f(i+1) = min(f(i), a[i+1])
    
    tip:
    转移方程的设计完全依赖于状态的定义，并不是什么样的状态定义，都能有状态转移方程，因此，状态定义决定了该DP方法能否实现
   ```

2. 初始条件的设置： Dp本质还是迭代，总要有一个迭代的初值。

3. 特殊处理小size的问题：有些情况，由于size太小，没法带入转移方程中。

根据该问题，依次回答上述问题：

1. 大问题与小问题的关系

   ```
    1）状态定义：我们定义max_profit为第i天的最大收益
    2）状态转移方程：
    第i天的最大收益和第i-1天的最大收益之间的关系：
        i) 最大收益不是第i天抛出的，                        ---最大收益和第i天的价格无关
        ii）最大收益是在第i-1天前某天买入的，并在第i天抛出的，  ---与第i天的价格有关
   
    因此第i天的最大收益等于：第i天抛出所造成的最大收益 和 第i-1天之前的最大收益 中的最大值
    即：
    前i天的最大收益 = max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}
    其中：
    前i-1天中的最小价格需时时更新并记录
   ```

2. 初始条件：

   ```
    min 和 max_profit
    min可以等于第一天的price
    max_profit可以等于0， 因为最大收益的最小值就是0， 用人话叫，最低也不能赔了
   ```

3. 小于最小问题的特殊情况： 当list的长度为0 和 1 时， 没有办法带入转移公式中，需要特殊处理。

```ruby
class Solution:
    def maxProfit(self, prices) -> int:


        if len(prices) <= 1:
            return 0

        min_input = prices[0]
        max_profit = 0
        for p in prices[1:]:
            min_input = min(p, min_input)
            max_profit = max(max_profit, p - min_input)

        return max_profit
```



## 32.最长有效括号(困难)

输入：s = "())((())"

输出：4

解释：最长有效括号序列是"(())"

比较难的是分析如何用动态规划来解。

用dp[i]表示以 i 为结尾的有效序列的长度。

有效括号序列的结尾一定是")"，所以我们只看右括号：

1. 序列结尾的形式是"......()"，那么dp[i] = dp[i-2] + 2；

2. 序列结尾的形式是"......))"，这种情况下，我们要找以 i-1 为结尾的有效序列的左边是不是有个"("，形如"...(...))"，这时要加上dp[i-1]+2，另外还要把坐括号左边的有效序列长度加上，即dp[i-dp[i-1]-2]，所以：

   $dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]$

<img src="./typora-user-images/image-20230530233745010.png" alt="image-20230530233745010" style="zoom:50%;" />

~~~python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        # dp
        n = len(s)
        dp = [0] * n
        maxlen = 0
        for i in range(n):
            if i-1 >= 0:
                if s[i] == ')': 
                    if s[i-1] == '(':
                        if i == 1:
                            dp[1] = 2
                        else:
                            dp[i] = dp[i-2] + 2
                    elif i-dp[i-1]-1 >= 0 and s[i-dp[i-1]-1] == '(':
                        dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]
                    maxlen = max(maxlen, dp[i])
        return maxlen
~~~



## 300.最长递增子序列

输入：[1,3,6,7,9,4,10,5,6]

输出：6

解释：1,3,6,7,9,10长度为6

### DP

dp[i]值由前面序列中比当前值nums[i]小的子序列增加1转移来。

~~~python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        res = 1
        dp = [1]
        for i in range(1, len(nums)):
            max_len = 0
            for j in range(i):
                if nums[j] < nums[i] and dp[j] > max_len:
                    max_len = dp[j]
            dp.append(max_len + 1)
            res = max(res, max_len+1)
        return res
~~~

时间复杂度：$O(n^2)$

### 二分法

使用 `bisect.bisect_left`，二分查找有序数组插入元素后仍保持有序的位置（最左边）。

| num  | 有序数组 (list_num) | 以该元素结尾的最长上升子序列 - 1 (list_max) |
| ---- | ------------------- | ------------------------------------------- |
| 1    | [1]                 | [0]                                         |
| 3    | [1,3]               | [0,1]                                       |
| 6    | [1,3,6]             | [0,1,2]                                     |
| 7    | [1,3,6,7]           | [0,1,2,3]                                   |
| 9    | [1,3,6,7,9]         | [0,1,2,3,4]                                 |
| 4    | [1,3,4,7,9]         | [0,1,2,3,4,2]                               |
| 10   | [1,3,4,7,9,10]      | [0,1,2,3,4,2,5]                             |
| 5    | [1,3,4,5,9,10]      | [0,1,2,3,4,2,5,3]                           |
| 6    | [1,3,4,5,6,10]      | [0,1,2,3,4,2,5,3,4]                         |



~~~python
import bisect
def max_order(lists):
    list_num = []
    list_max = []
    for i in lists:
        local = bisect.bisect_left(list_num, i)
        if local == len(list_num):
            list_num.append(i)
            list_max.append(local)
        else:
            list_num[local] = i
            list_max.append(local)
    return list_max
~~~

二分法时间复杂度 $O(n\log n)$。



# 二维动态规划

## 双蛋问题

### 特殊情况

描述：有一个 $100$ 层的大楼，有 $N$ 个鸡蛋，拿鸡蛋往下扔的时候，鸡蛋碎或者不碎有一个临界楼层，最少扔几次（$M$）可以找出临界楼层？

**一个鸡蛋的情况**

$N=1,M=100$

只能从第一层开始一层一层往上试。因为如果直接从50楼往下扔，鸡蛋碎了，就只能知道临界楼层在1~50层，而无法得知具体哪一层。

**无限个鸡蛋的情况**

$N=\infin, M=7$

这时可以使用二分法，$2^M \ge 100, M \ge 6.64, M = 7$。

**两个鸡蛋的情况**

$N=2, M=14$

1. 鸡蛋A的尝试楼层：10, 20, 30, ..., 100；鸡蛋B的尝试楼层：最多9次（A的取值间隔），那么最坏的情况下尝试 $10+9=19$ 次，$M=19$。

<img src="./typora-user-images/DP1.png"/>

2. 上面方法不是最优的，因为尝试次数在比较大的一个区间变动，考虑A的尝试楼层设置为不均匀的区间，随着A尝试次数的增加，B的尝试次数随之减少。假设A第一次在 $n$ 层尝试，之后递减 $1$。
   
   <img src="./typora-user-images/DP2.png"/>
   
   $$
   1+2+...+(n-2)+(n-1)+n =\frac{n(n-1)}{2} \ge 100\\
   n \ge 13.65 \\
   n = 14
   $$
   也就是说A的尝试楼层为：14, 27, 39, 50, 60, 69, 77, 84, 90, 95, 99, 100。

   B的尝试次数分别为：13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 0。

### 一般情况：递归思想

假设有T层楼，N个鸡蛋，求M值。

M可以写成是T和N的一个函数：$M(T,N)$

假设第一个蛋在 $k$ 层扔下去，那么两种情况，蛋碎了，蛋没碎。

假如蛋碎了，则临界楼层在 $1\sim k$ 层，还需要扔 $M(k,N-1)$ 次；假如蛋没碎，则临界楼层在 $k\sim T$ 层，还需要扔 $M(T-k,N)$次。

$M_k(T,N) = 1 + \max\{M(k,N-1),M(T-k,N)\}$

$M(T,N) = \min\{M_1, M_2, M_3, ..., M_T\}$

将其写入一张表中，第一行和第一列是可以直接确定的：

| T\N     | 0    | 1    | 2    | 3    | 4    | ...  | N    |      |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **0**   | 0    | 0    | 0    | 0    | 0    | ...  | 0    |      |
| **1**   | 0    | 1    | 1    | 1    | 1    | ...  | 1    |      |
| **2**   | 0    | 2    | 2    | 2    | 2    | ...  | 2    |      |
| **3**   | 0    | 3    | 2    | 2    | 2    | ...  | 2    |      |
| **...** | ...  | ...  | ...  | ...  | ...  | ...  | ...  |      |
| **100** | 0    | 100  | 14   | 9    | 8    | ...  | 7    |      |
| **...** | ...  | ...  | ...  | ...  | ...  | ...  | ...  |      |
| **T**   | 0    | T    | ...  | ...  | ...  | ...  | ...  |      |

$$
\begin{align}
M(2,2)&=\min\{M_1,M_2\}\\
			&=\min\{(1+\max\{M(1,1),M(1,2)\}),(1+\max\{M(2,1),M(0,2)\})\}\\
			&=\min\{(1+\max\{1,1\}),(1+\max\{2,0\})\}\\
			&=\min\{2,3\}\\
			&=2
\end{align}
$$

# 动态规划+网格

求网格中最大正方形的面积：

输入：

~~~python
grid = 
[[1,0,1,0,0],
 [1,0,1,1,1],
 [1,1,1,1,1],
 [1,0,1,1,1]
]
~~~

输出：

~~~
9
~~~

状态转移：

网格内的最大

|       |      | 0    | 1    | 2    | 3    | 4    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- |
|       | 0    | 0    | 0    | 0    | 0    | 0    |
| **0** | 0    | 1    | 0    | 1    | 0    | 0    |
| **1** | 0    | 1    | 0    | 1    | 1    | 1    |
| **2** | 0    | 1    | 1    | 1    | 2    | 2    |
| **3** | 0    | 1    | 2    | 2    | 2    | 3    |

dp矩阵的每个位置的值 $dp[i][j]$ 表示网格的 $grid[:i][:j]$ 所记录的最大正方形的边长。

当前取值为1时，最大正方形的边长为其左侧，上侧，坐上侧记录的最小值➕1。

~~~python
def max_area(grid):
	m = len(grid)
	n = len(grid[0])
	dp = [[0]*(n+1) for _ in range(m+1)]
	max_val = 0
	for i in range(1, m+1):
		for j in range(1, n+1):
			if grid[i-1][j-1] == 1:
				dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1]) + 1
				max_val = max(max_val, dp[i][j])
			else:
				continue
	return max_val*max_val
~~~



