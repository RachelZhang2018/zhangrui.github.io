---

layout: post

title: "Leetcode-滴滴数学题和算法题"

---

# 四人过桥问题

**问题背景**：

有4个人要过一座桥，都站在桥的某一边,要让他们在17分钟内全部通过这座桥。

这时是晚上，他们只有一个手电筒，最多只能让两个人同时过桥。

不管是谁过桥,不管是一个人还是两个人,必须要带着手电筒。手电筒必须要传来传去,不能扔过去。

每个人过桥的速度不同,两个人必须以较慢的那个人的速度过桥。

　甲：过桥需要1分钟；
　乙：过桥需要2分钟；
　丙：过桥需要5分钟；
　丁：过桥需要10分钟.
　　

比如,如果甲与丁首先过桥,等他们过去时,已经过去了10分钟。

如果让丁将手电筒送回去,那么等她到达桥的另一端时,总共用去了20分钟,行动也就失败了。

怎样让这4个人在17分钟内过桥?

**解决方案**：

（1）首先，甲和乙先过桥，花费2分钟，接着甲返回，花费1分钟，总共花费3分钟；

（2）然后，丙和丁过桥，花费10分钟；

（3）最后，乙返回，花费2分钟，甲和乙一起过桥，花费2分钟，总共花费4分钟。

上述步骤时间相加刚好17分钟。



**问题分析**：

由于一次过桥最多两人且手电筒需要往返传递，因此以两个成员过桥为一个分析单位，计算过桥时间。

以按过桥时间递增的顺序将 n 个成员排序。

a[1]是最快的人，a[2]次之，a[n-1]是倒数第二慢的人，a[n]是最慢的人。

在相对状况下考虑，则有两种方案：

- 方案一：用最快的成员a[1]传递手电筒帮助最慢的a[n]和a[n-1]过桥，易知来回所用的时间为 `2*a[1]+a[n]+a[n-1]`

- 方案二：用最快的成员a[1]和次快的成员a[2]传递手电筒帮助最慢的a[n]和a[n-1]过桥，具体方案如下：

    1. a[1]和a[2]到对岸, 所用时间为a[2];
    
    2. a[1]返回, 将手电筒给最慢的a[n]和a[n-1], 并且a[n]和a[n-1]到对岸后将手电筒交给a[2], 所用时间为: a[1]+a[n];
    
    3. a[2]返回, 所用时间为a[2];
    
    综合起来方案二所用的总时间为 2*a[2]+a[n]+a[1]。

显然，两种方案的好坏取决于他们的总时间，若 $2*a[1]+a[n]+a[n-1]<2*a[2]+a[n]+a[1]$，即采用第一种方案，否则采用第二种方案。

我们每次帮助最慢的两个人过桥，累加时间，最后可能出现的两种情况：

    1. 对岸剩下两个队员, 全部过桥, 时间为a[2];
    
    2. 对岸剩下三个队员, 用最快的成员传递手电筒, 帮助最慢的成员过桥, 然后与次慢的成员一起过桥, 时间为: a[1]+a[n-1]+a[n], 注意, 这里的n=3.


**代码**：

~~~c++
#include <iostream> 
#include <cstdio>
#include <algorithm>
using namespace std;
 
int n,i,k,a[1024]; //人数为n,i,j,k为循环控制变量，数组存储过桥时间 
int sum=0; //过桥总时间
int main()
{
	scanf("%d",&n);
	for(i=1;i<=n;i++)
	scanf("%d",&a[i]);
	if(n==1)
	{
		printf("%d\n%d\n",a[1],a[1]);
		return 0;
	}
	k=n;
	sort(a+1,a+n+1);
	while(k>3)	//求总时间 
	{
		if(a[1]+a[k-1]<2*a[2])
		sum+=a[k]+a[1]*2+a[k-1];
		else
		sum+=a[2]*2+a[1]+a[k];
		k-=2;
	}
	if(k==2)	//对岸剩下两个成员 
	sum+=a[2];
	else		//对岸剩下3个成员 
	sum+=a[1]+a[2]+a[3];
	printf("%d\n",sum);	//输出n个人的过桥时间
	k=n;
	while(k>3)	//输出具体方案 
	{
		if(a[1]+a[k-1]<2*a[2])	//输出用a[1]传递手电筒方案 
		printf("%d %d\n%d\n%d %d\n%d\n",a[1],a[k],a[1],a[1],a[k-1],a[1]);
		else						//输出用a[1]、a[2]传递手电筒发的方案
		printf("%d %d\n%d\n%d %d\n%d\n",a[1],a[2],a[1],a[k],a[k-1],a[2]);
		k-=2;
	} 
	if(k==2)
	printf("%d %d\n",a[1],a[2]);
	else
	printf("%d %d\n%d\n%d %d\n",a[1],a[3],a[1],a[1],a[2]);
	return 0;
}
~~~

# 容器倒水问题



# 随机数生成器





# 集齐盲盒

==几何随机分布（Geometric Distribution）==：每次试验只有成功和失败两种结果，每次试验成功的概率都是一样的。几何随机分布可以建模：第一次成功前有0次失败的概率；第一次成功前有1次失败的概率；第一次成功前有2次失败的概率；……直到无穷次。

问题：n 种盲盒，每种的个数是无限个，问平均购买多少个盲盒可以集齐 n 种盲盒？（每次购买，抽到每种盲盒的概率是一样的）

成功的事件：抽到和手中不一样的盲盒，概率为 $p$。

失败的事件：抽到和手中一样的盲盒，概率为 $q$。

假设手中有 k 种不一样的盲盒，那么再抽一个盲盒，
$$
p = P(success) = \frac{n-k}{n} \\
q = P(fail) = \frac{k}{n} = 1 - P(success) = 1 - p
$$
X: 第一次成功时总的试验次数。
$$
P(X = x) = q^{x-1} p
$$
那么随机变量 X 的期望值是：
$$
\begin{align}
E[X] &= 1*p + 2*qp + 3*q^2p + ... \\
     &= \sum_{x=1}^{\infin} x*q^{x-1}p \\
     &= \sum_{x=1}^{\infin} x*(1-p)^{x-1}p \\
     &= \frac{1}{p}
\end{align}
$$
所以当手中有 k 个不一样的盲盒时，下一次再抽到一个不一样的盲盒的平均购买次数是：
$$
E[X] = \frac{1}{p} = \frac{n}{n-k}
$$
所以要集齐 n 个盲盒的购买次数是：
$$
\begin{align}
&\sum_{k=0}^{n-1} \frac{n}{n-k} \\
&=1+\frac{n}{n-1}+\frac{n}{n-2}+...+\frac{n}{2}+n \\
&=n(1+\frac{1}{2}+\frac{1}{3}+...+\frac{1}{n})
\end{align}
$$

# 自助法随机采样

问题：自助法随机采样过程中，对 n 个样本进行 n 次==有放回==的随机采样，当 n 趋向于无穷大时，最终有多少数据从未被选择过？

推导：

一个样本在一次抽样中未被选择的概率是
$$
(1 - \frac{1}{n})
$$
n 次抽样均未被选择的概率是
$$
(1 - \frac{1}{n})^n
$$
已知
$$
\lim_{n\rightarrow\infin}(1+\frac{1}{n})^n = e
$$
当 n 趋向于无穷大时的概率为
$$
\begin{align}
&\lim_{n\rightarrow\infin}(1-\frac{1}{n})^n\\
&=\lim_{n\rightarrow\infin}(\frac{1}{(1+\frac{1}{n-1})^n})\\
&=\frac{1}{\lim_{n\rightarrow\infin}{(1+\frac{1}{n-1})^{n-1}}} \cdot
\frac{1}{\lim_{n\rightarrow\infin}{(1+\frac{1}{n-1})}}\\
&=\frac{1}{e}\\
&\approx 0.368
\end{align}
$$
所以有36.8%的样本从未被选择过。



另一种思考方式：

和上面抽盲盒的问题类似，只是抽盲盒是可以抽无限次，而本问题只能抽 n 次。

比如说 n=100，那么在抽100次时能够抽到的不一样的盲盒个数是满足：
$$
1+\frac{100}{99}+\frac{100}{98}+\frac{100}{97}+...+\frac{100}{100-k} < 100
$$
的 k 的大小。