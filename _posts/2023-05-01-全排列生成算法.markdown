---

layout: post

title: "Leetcode-全排列生成算法"

---

# 字典序法

规定元素之间的大小关系，以此比较两个序列的大小。比如说规定"12345"<"12354"，规定"abcde"<"abced"等。从一个最小的序列开始（所有元素升序排列），每次生成恰好比它大的一个序列，最后生成最大的序列（所有元素降序排列）。

步骤：

1. 从序列右端开始，找到第一个反序的元素$P_j$（小于右边元素）。这个元素是需要被往右移动的，操作将增大整个序列。
2. 找到$P_j$右边所有大于它的元素中，最小的那一个$P_k$。本操作保证生成的序列恰好大于本序列。
3. 交换$P_j$和$P_k$，本操作将前缀的锚点设定为一个更大的数$P_k$。
4. 将序号大于位置 $j$ 的元素全部升序排列。由于原本 $j$ 右边的元素就都是降序，而 $P_j < P_k$ 并且 $P_j$ 大于 $P_k$ 右边的所有元素，所以两者交换以后，右边元素还是全降序排列，现在要全逆序变成升序。

栗子🌰：

1234567**8**9

123456**7**98

1234568**7**9

123456**8**97

1234569**7**8

12345**6**987

1234576**8**9

......

可以看到锚点渐渐往左移动，后缀渐渐变成降序，生成的序列越来越大。

# 递增进位制法

递增进制是随着位数增加，进制也增加的计数方法。一般上最右边的位上底数是2，往左依次增加1，例如十进制100的递增进位制表示为$(100)_{10}=(4020)_{asc}=4*4!+0*3!+2*2!+0*1!$。

$n$ 位的递增进位制能表示 $n!$ 个数字，刚好和 $n$ 个元素全排列的个数相同，考虑这之间建立映射。

栗子🌰：

求839647521的下100个排列。

步骤：

1. 求原中介数。中介数每一位是其后小于它的数字的个数：8后面有7个数字小于它，3后面有2个数字小于它，9后面有6个数字小于它……所以原中介数为72642321（注意！8位数，最后一个0不要了）。
2. 求新中介数。100的递增进位制表示为4020，$72642321+4020=72652011$。
3. 求新排列。辅助数字123456789，新中介数的第一位是 $x_1$，从辅助数字第一个开始数 $x_1+1$ 个即为新排列第一位的数字，然后将 $x_1+1$ 从辅助数字中去掉。

| 新中介数当前位 | 辅助数字              | 新排列数 |
| -------------- | --------------------- | -------- |
| 初始           | 1 2 3 4 5 6 7 **8** 9 |          |
| 7              | 1 2 **3** 4 5 6 7 - 9 | 8        |
| 2              | 1 2 - 4 5 6 7 - **9** | 3        |
| 6              | 1 2 - 4 5 6 **7** - - | 9        |
| 5              | 1 2 - **4** 5 6 - - - | 7        |
| 2              | **1** 2 - - 5 6 - - - | 4        |
| 0              | - 2 - - **5** 6 - - - | 1        |
| 1              | - 2 - - - **6** - - - | 5        |
| 1              | - **2** - - - - - - - | 6        |
| 最后补位       | - - - - - - - - -     | 2        |

最后得到新排列为：839741562

# 插入法

如果已知n-1个元素的排列，将n插入到排列的不同位置，就得到了n个元素的排列。用这种方法可以产生出任意n个元素的排列。

这个方法有一个缺点：为了产生n个元素的排列，我们必须知道并存储所有n-1个元素的排列，然后才能产生出所有n阶排列。

# 邻位对换法

by Johnson-Trotter

