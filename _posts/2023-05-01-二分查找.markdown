---

layout: post

title: "Leetcode-二分查找"

---

# 二分查找

==旋转排序数组==

## 33.搜索旋转排序数组

~~~python
# input: [4,5,6,7,0,1,2], target=0
# output: 4

def search_rotated_sorted_array(nums, target):
	n = len(nums)
	left, right = 0, n-1
	while left <= right:
		#mid = (left + right) // 2 # 此种写法怕溢出
		mid = left + (right - left) // 2
		if nums[mid] == target:
			return mid
		if nums[left] <= nums[mid]:
			if nums[left] <= target < nums[mid]:
				right = mid - 1
			else:
				left = mid + 1
		else:
			if nums[mid] < target <= nums[right]:
				left = mid + 1
			else:
				right = mid - 1	
	return -1

nums = [4,5,6,7,0,1,2]
target = 0
print(search_rotated_sorted_array(nums, target))
~~~

## 81.搜索旋转排序数组II

数组中有重复元素的情况：

增加一种情况，当 $nums[left]==nums[mid]==nums[right]$ 时，无法判断下一个检索区间，则缩小区间范围，使得 `left+=1, right-=1`。

~~~python
class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        left = 0
        right = len(nums) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return True
            if nums[mid] == nums[left] and nums[mid] == nums[right]:
                left += 1
                right -= 1
            elif nums[left] <= nums[mid]:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
        return False
~~~

## 153.寻找旋转排序数组中的最小值(中等)

旋转排序数组中没有重复元素。

注意：==mid和right对比！==

如果用left和mid对比，当nums[left]<nums[mid]，最小值可能在左边（e.g. [0, 1, 2, 3]），也可能在右边（[2, 3, 0, 1]）。

~~~python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        n = len(nums)
        left = 0
        right = n - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[right] < nums[mid]: # minimum on right
                left = mid + 1
            else:
                right = mid
        return nums[left]
~~~

## 154.寻找旋转排序数组中的最小值II(困难)

有重复元素，比上题多一种情况，当mid和right相等时，不能确定最小值在左侧还是右侧，此时可以缩小区间。

$nums[pivot]<nums[high]$ 找左侧

<img src="./typora-user-images/rotated_sorted_array_1.png"/>

$nums[pivot]>nums[high]$ 找右侧

<img src="./typora-user-images/rotated_sorted_array_2.png"/>

$nums[pivot]==nums[high]$ 缩小区间

<img src="./typora-user-images/rotated_sorted_array_3.png"/>

~~~python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] < nums[right]:
                right = mid
            elif nums[mid] > nums[right]:
                left = mid + 1
            else:
                right -= 1
        return nums[left]
~~~

## 剑指Offer II 070.排序数组中只出现一次的数字

给定一个只包含整数的有序数组 nums ，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。

你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。

输入：[1,1,2,3,3,4,4,8,8]

输出：2

输入：[3,3,7,7,10,11,11]

输出：10

思路：观察数组长度奇数和偶数的时候，每次往左还是往右查找。

~~~python
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        left, right = 0, len(nums)-1
        while left < right:
            mid = left + (right - left) // 2
            if (mid - left) % 2 == 0:
                if nums[mid-1] == nums[mid]:
                    right = mid - 2
                elif nums[mid+1] == nums[mid]:
                    left = mid + 2
                else:
                    return nums[mid]
            else:
                if nums[mid-1] == nums[mid]:
                    left = mid + 1
                elif nums[mid+1] == nums[mid]:
                    right = mid - 1
                else:
                    return nums[mid]
        return nums[left]
~~~

==分割数组==

## 410.分割数组的最大值(困难)

<img src="./typora-user-images/image-20230605175417380.png" alt="image-20230605175417380" style="zoom:50%;" />

「使……最大值尽可能小」是二分搜索题目常见的问法。

low：数组中的最大值

high：数组的和

以它们的中间值mid为分割的最大值，遍历数组，一旦和超过mid，就划分到新的子数组中，同时count+1。

~~~python
class Solution:
    def splitArray(self, nums: List[int], k: int) -> int:
        # binary search
        low = max(nums)
        high = sum(nums)
        while low < high:
            mid = low + (high - low) // 2
            total = 0
            count = 1
            for num in nums:
                if total + num > mid:
                    count += 1
                    total = num
                else:
                    total += num
            if count > k: # increase mid
                low = mid + 1
            else: # decrease mid
                high = mid
        return low
~~~

注意⚠️

1. 循环条件是 `low < high`，否则陷入死循环；
2. 缩小范围时选择 `high = mid`，否则可能跳过答案。

