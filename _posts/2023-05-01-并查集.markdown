---

layout: post

title: "Leetcode-并查集"

---

# 定义

DSU(Disjoint Set Union): 维护若干个没有重叠的集合。

# 支持的操作

1. 合并并查集；
2. 查找元素所属集合（使用一个根节点代表整个集合）；

# 应用：朋友圈问题

We are given 5 individuals say, 0, 1, 2, 3, 4.

Following are relationships to be added:

0 <-> 2

4 <-> 2

3 <-> 1

Given queries like whether $x$ is a friend of $y$ or not. We basically need to create following 2 groups and maintain a quickly accessible connection among group items:

G1 = {0, 2, 4}

G2 = {1, 3}

当我们想知道 $x$ 和 $y$ 是不是在一个朋友圈的时候，可以使用并查集。



# 实现

## 初始化

`parent` 数组，存储每一个元素的父节点，初始化为自身。

parent = [0, 1, 2, 3, 4]

`rank` 数组，存储每一个集合的树高，初始化为1。

rank = [1, 1, 1, 1, 1]

## 查找

查找某个元素所在集合的根节点。

递归找父节点，直到找到 `parent[i] == i` 的这个节点，即为根节点。

找根节点有两个目的：

1. 合并两个集合的时候是把一个集合的根节点缀到另一个根节点下面；
2. 判断两个元素是否属于同一个集合的时候，只需判断其根节点是否相同。

==路径压缩==

查找的同时可以实现路径压缩。

由于每个集合的树的高度越矮，查询越快，所以可以利用缓存将查找路径上的每个节点缀到根节点下面。

<img src="typora-user-images/dsu_path_compression.png"/>

~~~python
def find(i):

	# If i is the parent of itself
	if Parent[i] == i:

		# Then i is the representative
		return i
	else:

		# Recursively find the representative.
		result = find(Parent[i])

		# We cache the result by moving i’s node
		# directly under the representative of this
		# set
		Parent[i] = result
	
		# And then we return the result
		return result

~~~

## 合并

判断两个树的高度，如果把矮的缀到高的根节点下面；

如果一样高，随便缀一个，记得根节点的 `rank+1`。



## 图解

 <img src="typora-user-images/image-20230525002907992.jpg" alt="image-20230525002907992" style="zoom:30%;" />

~~~python
# Python3 program to implement Disjoint Set Data
# Structure.

class DisjSet:
	def __init__(self, n):
		# Constructor to create and
		# initialize sets of n items
		self.rank = [1] * n
		self.parent = [i for i in range(n)]

	def find(i):
    if self.parent[i] == i:
      return i
    else:
      result = self.find(self.parent[i])
      self.parent[i] = result
      return result

	# Do union of two sets represented
	# by x and y.
	def Union(self, x, y):
		
		# Find current sets of x and y
		xset = self.find(x)
		yset = self.find(y)

		# If they are already in same set
		if xset == yset:
			return

		# Put smaller ranked item under
		# bigger ranked item if ranks are
		# different
		if self.rank[xset] < self.rank[yset]:
			self.parent[xset] = yset

		else if self.rank[xset] > self.rank[yset]:
			self.parent[yset] = xset

		# If ranks are same, then move y under
		# x (doesn't matter which one goes where)
		# and increment rank of x's tree
		else:
			self.parent[yset] = xset
			self.rank[xset] = self.rank[xset] + 1

# Driver code
obj = DisjSet(5)
obj.Union(0, 2)
obj.Union(4, 2)
obj.Union(3, 1)
if obj.find(4) == obj.find(0): # Yes
	print('Yes')
else:
	print('No')
if obj.find(1) == obj.find(0): # No
	print('Yes')
else:
	print('No')
~~~

# 复杂度

创建 $n$ 个元素的集合时间复杂度是 $O(n)$。

`find` 和 `union` 的时间复杂度是 $O(\log n)$。

一次操作的整体**时间复杂度**是 $O(n+\log n)$。

**空间复杂度**是 $O(n)$。

# 例题

https://www.geeksforgeeks.org/disjoint-set-data-structures/

https://blog.csdn.net/z_feng12489/article/details/105789587