---

layout: post

title: "Leetcode-二叉树"

---

# 建立一颗二叉树

二叉排序树的中序遍历结果递增有序。

~~~python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def build_binary_tree(elements):
    if not elements:
        return None

    # 使用列表中的第一个元素创建根节点
    root = TreeNode(elements[0])

    # 逐个构建子树
    for element in elements[1:]:
        insert_node(root, element)

    return root

def insert_node(root, value):
    if not root:
        return TreeNode(value)

    # 如果插入的值小于当前节点的值，则插入左子树
    if value < root.value:
        root.left = insert_node(root.left, value)
    # 如果插入的值大于或等于当前节点的值，则插入右子树
    else:
        root.right = insert_node(root.right, value)

    return root

def search_node(root, value):
    if not root or root.value == value:
        return root

    if value < root.value:
        return search_node(root.left, value)
    else:
        return search_node(root.right, value)

def find_minimum_value_node(root):
    current = root

    while current.left:
        current = current.left

    return current

def delete_node(root, value):
    if not root:
        return root

    if value < root.value:
        root.left = delete_node(root.left, value)
    elif value > root.value:
        root.right = delete_node(root.right, value)
    else:
        if not root.left:
            return root.right
        elif not root.right:
            return root.left

        temp = find_minimum_value_node(root.right)
        root.value = temp.value
        root.right = delete_node(root.right, temp.value)

    return root
~~~

删除操作：

1. 删除叶节点，只需调整双亲指针域；
2. 被删节点只有左子树或右子树，则用左子树或右子树替换被删节点；
3. 被删节点左右子树都有，则用左子树最大节点 g 替换，再删 g；或用右子树最小节点 w 替换，再删 w。（g 和 w 最多只有一个孩子）



<img src="/_posts/typora-user-images/删除二叉树.jpg" alt="删除二叉树"  />

# 树的遍历

~~~python
def preorder(root):
    if not root:
        return
    print(root.value)
    preorder(root.left)
    preorder(root.right)

def preorder_stack(root):
    if not root:
        return
    mystack = []
    node = root
    while node or mystack:
        while node:
            print(node.value)
            mystack.append(node)
            node = node.left
        node = mystack.pop()
        node = node.right

def inorder(root):
    if not root:
        return
    inorder(root.left)
    print(root.value)
    inorder(root.right)

def inorder_stack(root):
    if not root:
        return
    mystack = []
    node = root
    while node or mystack:
        while node:
            mystack.append(node)
            node = node.left
        node = mystack.pop()
        print(node.value)
        node = node.right

def postorder(root):
    if not root:
        return
    postorder(root.left)
    postorder(root.right)
    print(root.value)

def postorder_stack(root):
    if root == None:
        return
    myStack1 = []
    myStack2 = []
    node = root
    myStack1.append(node)
    while myStack1:                   
        node = myStack1.pop()
        if node.left:
            myStack1.append(node.left)
        if node.right:
            myStack1.append(node.right)
        myStack2.append(node)
    while myStack2:                        
        print myStack2.pop().value

~~~



# 题库

## 236.二叉树的最近公共祖先(中等)

迭代返回的值 $f_x$ 是以 $x$ 为根节点的子树中是否包含 $p$ 和 $q$。

而判断是否为最近公共祖先的条件是：

1. 左子树包含一个目标值&&右子树包含一个目标值；
2. 左子树或右子树包含一个目标值&&当前节点值为某个目标值。

~~~python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        answer = None
        def dfs(root, p, q):
            if not root:
                return False
            linclude = dfs(root.left, p, q)
            rinclude = dfs(root.right, p, q)
            # lca conditions
            if (linclude and rinclude) or ((linclude or rinclude) and (root.val == p.val or root.val == q.val)):
                nonlocal answer
                answer = root
                return True
            return linclude or rinclude or root.val == p.val or root.val == q.val
        dfs(root, p, q)
        return answer
~~~

answer需要==nonlocal==关键字。

<img src="/_posts/typora-user-images/image-20230611232648482.png" alt="image-20230611232648482" style="zoom:50%;" />

输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 2, q = 0

输出：3

输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 7, q = 5

输出：5



## 题目合集

~~~cpp
#include <iostream>

using namespace std;


 // Definition for a binary tree node.
 struct TreeNode {
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode() : val(0), left(nullptr), right(nullptr) {}
	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
	TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 };
// 100
bool isSameTree(TreeNode* p, TreeNode* q) {
	if (p == nullptr && q == nullptr) return true;
	else if (p == nullptr || q == nullptr) return false;
	else if (p -> val != q -> val) return false;
	else return isSameTree(p -> left, q -> left) && isSameTree(p -> right, q -> right);
}

// 101
bool isSameVal(TreeNode* t1, TreeNode* t2){
	if (t1 == nullptr && t2 == nullptr) return true;
	else if(t1 == nullptr || t2 == nullptr) return false;
	else if(t1 -> val != t2 -> val) return false;
	else return isSameVal(t1->left, t2->right) && isSameVal(t1->right, t2->left);
}

bool isSymmetric(TreeNode* root) {
	if(root == nullptr) return true;
	else return isSameVal(root->left, root->right);
}

// 104
int maxDepth(TreeNode* root) {
	if(root == nullptr) return 0;
	int maxLeft = maxDepth(root->left);
	int maxRight = maxDepth(root->right);
	int maxD = (maxLeft >= maxRight)? maxLeft : maxRight;   
	return ++maxD;   
}

// 108
TreeNode* sortedArrayToBST(vector<int>& nums) {
	if(nums.size() == 0) return nullptr;
	int mid_ind = nums.size()/2;
	int root_val = nums[mid_ind];
	TreeNode* root = new TreeNode;
	root->val = root_val;
	if(mid_ind == 0) {
		root->left = nullptr;
		root->right = nullptr;
	}
	else {
		vector<int> leftArray(nums.begin(),nums.begin()+mid_ind);
		root->left = sortedArrayToBST(leftArray);
		if (mid_ind+1 == nums.size()) {
			root->right = nullptr;
		}
		else {
			vector<int> rightArray(nums.begin()+mid_ind+1,nums.end());
			root->right = sortedArrayToBST(rightArray);
		}
	}
	return root;
}

// 110.Balanced Binary Tree

bool isBalanced(TreeNode* root) {
	if(root == nullptr) return true;
	else {
		int leftHeight = maxDepth(root->left);
		int rightHeight = maxDepth(root->right);
		if (abs(leftHeight - rightHeight) <= 1 && isBalanced(root->left) && isBalanced(root->right)) return true;
		else return false;
	}    
}

// 111. Minimum Depth of Binary Tree
int minDepth(TreeNode* root) {
	if(root == nullptr) return 0;
	if(root->left == nullptr && root->right == nullptr) return 1;
	else if(root->left == nullptr) return minDepth(root->right)+1;
	else if(root->right == nullptr) return minDepth(root->left)+1;
	else {
		int minLeft = minDepth(root->left);
		int minRight = minDepth(root->right);
		int min = (minLeft <= minRight)? minLeft:minRight;
		return ++min;
	} 	       
}

// 112. Path Sum
bool hasPathSum(TreeNode* root, int targetSum) {
	if(root == nullptr) return false;
	targetSum = targetSum - root->val;
	if(root->left == nullptr && root->right == nullptr) return targetSum==0;
	else return hasPathSum(root->left, targetSum) || hasPathSum(root->right, targetSum);
}

// 113. Path Sum II
void traverse(TreeNode* root, vector<vector<int>>& paths, vector<int> path, int targetSum) {
	path.push_back(root->val);
	if(!root->left && !root->right && root->val == targetSum) {
		paths.push_back(path);
	}
	targetSum = targetSum - root->val;
	if(root->left) traverse(root->left, paths, path, targetSum);
	if(root->right) traverse(root->right, paths, path, targetSum);
}

vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
	vector<vector<int>> paths;
	vector<int> path;
	if(!root) return paths;
	traverse(root, paths, path, targetSum);
	return paths;
}

// 226. Invert Binary Tree
TreeNode* invertTree(TreeNode* root) {
	if(root == nullptr) return root;
	TreeNode* temp = root->left;
	root->left = root->right;
	root->right = temp;
	invertTree(root->left);
	invertTree(root->right);
	return root;       
}

~~~

